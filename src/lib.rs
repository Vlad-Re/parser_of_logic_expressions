//! Simple parser for propositional logic expressions.
//!
//! This crate provides a parser for propositional (boolean) logic expressions
//! such as `a & (b -> c)`. The grammar recognizes literals (atoms),
//! grouping with parentheses or brackets, negation, and binary operators
//! with precedence: AND, XOR, OR, IMPLICATION, EQUIVALENCE.
//!
//! Grammar rules (high level):
//! - `atom` — identifiers and boolean literals (true/false)
//! - `primary` — `atom` or grouped expressions `( ... )`, `[ ... ]`, `{ ... }`
//! - `negation` — zero or more `!` followed by a `primary`
//! - `and` — `negation` chained with `&` or `↑`
//! - `xor`, `or`, `implication`, `expression` — composed with appropriate precedence
//! - `file` — multiple `expression` separated by newlines

use pest::iterators::Pair;
use pest_derive::Parser;
use thiserror::Error;

#[derive(Parser)]
#[grammar = "grammar.pest"]
/// The `LogicParser` type — generated by `pest` from `grammar.pest`.
pub struct LogicParser;

/// Library-level errors.
#[derive(Error, Debug)]
pub enum LogicError {
    /// Generic parse or processing error.
    #[error("parse error: {0}")]
    Parse(String),
}

/// Make a simple parenthesized representation of a flat expression.
///
/// Input must be a `Pair<Rule>` corresponding to an `expression` from the
/// grammar. This helper currently tokenizes by whitespace and builds a
/// left-associative parenthesization.
pub fn make_parantecies(pair: Pair<Rule>) -> String {
    let src = pair.as_str();
    let parts: Vec<&str> = src.split_whitespace().collect();
    if parts.is_empty() {
        return "".to_string();
    }
    if parts.len().is_multiple_of(2) {
        return src.to_string();
    }

    let mut operands: Vec<&str> = Vec::new();
    let mut ops: Vec<&str> = Vec::new();
    let mut i = 0_usize;
    while i < parts.len() {
        if i.is_multiple_of(2) {
            operands.push(parts[i]);
        } else {
            ops.push(parts[i]);
        }
        i += 1_usize;
    }

    let mut result = "(".to_string();
    result.push_str(operands[0]);
    result.push(' ');
    result.push_str(ops[0]);
    result.push(' ');
    result.push_str(operands[1]);
    result.push(')');

    let mut m = 1_usize;
    while m < ops.len() {
        let mut new_result = "(".to_string();
        new_result.push_str(&result);
        new_result.push(' ');
        new_result.push_str(ops[m]);
        new_result.push(' ');
        new_result.push_str(operands[m + 1]);
        new_result.push(')');
        result = new_result;
        m += 1;
    }

    result
}
