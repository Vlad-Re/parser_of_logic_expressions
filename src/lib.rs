#![doc = include_str!("../docs.md")]

use pest::iterators::Pair;
use pest_derive::Parser;
use thiserror::Error;

#[derive(Parser)]
#[grammar = "grammar.pest"]
/// The `LogicParser` type â€” generated by `pest` from `grammar.pest`.
pub struct LogicParser;

/// Library-level errors.
#[derive(Error, Debug)]
pub enum LogicError {
    #[error("parse error: {0}")]
    Parse(String),
}

/// Make a simple parenthesized representation of a flat expression.
///
/// Input must be a `Pair<Rule>` corresponding to an `expression` from the
/// grammar. This helper currently tokenizes by whitespace and builds a
/// left-associative parenthesization.
pub fn make_parantecies(pair: Pair<Rule>) -> String {
    let src = pair.as_str();
    let parts: Vec<&str> = src.split_whitespace().collect();
    if parts.is_empty() {
        return "".to_string();
    }
    if parts.len().is_multiple_of(2) {
        return src.to_string();
    }

    let mut operands: Vec<&str> = Vec::new();
    let mut ops: Vec<&str> = Vec::new();
    let mut i = 0_usize;
    while i < parts.len() {
        if i.is_multiple_of(2) {
            operands.push(parts[i]);
        } else {
            ops.push(parts[i]);
        }
        i += 1_usize;
    }

    let mut result = "(".to_string();
    result.push_str(operands[0]);
    result.push(' ');
    result.push_str(ops[0]);
    result.push(' ');
    result.push_str(operands[1]);
    result.push(')');

    let mut m = 1_usize;
    while m < ops.len() {
        let mut new_result = "(".to_string();
        new_result.push_str(&result);
        new_result.push(' ');
        new_result.push_str(ops[m]);
        new_result.push(' ');
        new_result.push_str(operands[m + 1]);
        new_result.push(')');
        result = new_result;
        m += 1;
    }

    result
}
